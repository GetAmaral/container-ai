================================================================================
CORRECAO A: FLUXO DE BUSCA (busca-total-evento)
================================================================================

FLUXO ATUAL:
  Webhook → Edit Fields2 → criterios → Get a row2 → Send message
  → If1 → Code4 → Get many rows9 → Aggregate8 → If5 → ...

FLUXO NOVO:
  Webhook → Edit Fields2 → criterios → Get a row2 → Send message
  → If1 ─┬→ Code4 → Get many rows9 (normais) ─┐
         └→ Get many rows RECORRENTES ──────────┘
                                                 ↓
                                     Code: Expandir Recorrentes
                                                 ↓
                                            Aggregate8 → If5 → ...

================================================================================
PASSO 1: MODIFICAR O Code4
================================================================================

No Code4, adicionar "&is_recurring=is.false" no queryString,
para que ele so busque eventos NAO recorrentes.

Trocar a linha final de "params" por:

  // Adicionar filtro para excluir recorrentes
  params.push('is_recurring=is.false');

Codigo completo do Code4 atualizado:

---INICIO CODE4---
const criterio = $('Edit Fields2').item.json;

const startRaw = criterio.start_event || null;
const endRaw = criterio.end_event || null;

const COL_START = 'start_event';
const COL_END   = 'end_event';

function toPostgrestDate(raw) {
  if (!raw) return null;
  let s = String(raw).trim();
  s = s.replace(' ', 'T');
  s = s.replace(/([+-]\d{2})$/, '$1:00');
  const d = new Date(s);
  if (isNaN(d.getTime())) return null;
  return d.toISOString().replace(/\.\d{3}Z$/, 'Z');
}

const startUtc = toPostgrestDate(startRaw);
const endUtc   = toPostgrestDate(endRaw);

const params = [];
if (endUtc)   params.push(`${COL_START}=lte.${endUtc}`);
if (startUtc) params.push(`${COL_END}=gte.${startUtc}`);

// >>> NOVO: Excluir recorrentes (serao buscados separadamente)
params.push('is_recurring=is.false');

const queryString = params.join('&');

return [{
  json: {
    queryString,
    debug: {
      criterio,
      startRaw,
      endRaw,
      startUtc,
      endUtc
    }
  }
}];
---FIM CODE4---

================================================================================
PASSO 2: ADICIONAR NODE "Get many rows RECORRENTES"
================================================================================

Adicione um novo node Supabase em PARALELO com o Code4,
saindo do If1 (branch true).

  Node type: Supabase (Get All)
  Name: "Get Recorrentes"
  Table: calendar
  Return All: true
  Filter Type: string
  Filter String:
    user_id=eq.{{ $('Edit Fields2').item.json.user_id }}&is_recurring=is.true&active=is.true

  Marque: Always Output Data = ON

OPCIONAL - Se o usuario buscou por nome, adicione tambem:
  Se nome_evento nao vazio:
    &event_name=ilike.*{{ $('Edit Fields2').item.json.nome }}*

================================================================================
PASSO 3: ADICIONAR CODE NODE "Expandir Recorrentes"
================================================================================

Adicione um Code node que recebe:
  - Input 1: saida do "Get many rows9" (eventos normais)
  - Input 2: saida do "Get Recorrentes" (eventos recorrentes)

Para juntar dois inputs, use um node Merge (mode: Append)
ANTES do Code node, ou use $items() dentro do Code.

Alternativa mais simples: use um Merge node (Append) para juntar
os dois, e no Code node faca a separacao por is_recurring.

---INICIO CODE EXPANDIR---
// ============================================================
// Code: Expandir Recorrentes na Busca
// ============================================================
// Recebe todos os items (normais + recorrentes) do Merge
// Separa, expande os recorrentes, junta e retorna.

const allItems = $input.all().map(i => i.json);

// Range de busca
const criterio = $('Edit Fields2').item.json;
const startRaw = criterio.start_event || '';
const endRaw = criterio.end_event || '';

if (!startRaw || !endRaw) {
  // Sem range de data, retornar so os normais
  const normais = allItems.filter(e => !e.is_recurring);
  return normais.map(e => ({ json: e }));
}

function parseDate(raw) {
  let s = String(raw).trim();
  s = s.replace(' ', 'T');
  s = s.replace(/([+-]\d{2})$/, '$1:00');
  return new Date(s);
}

const rangeStart = parseDate(startRaw);
const rangeEnd = parseDate(endRaw);

// Separar
const normais = allItems.filter(e => !e.is_recurring);
const recorrentes = allItems.filter(e => e.is_recurring && e.rrule);

// ─── RRULE PARSER ───
function parseRRule(rruleStr) {
  if (!rruleStr) return {};
  const str = rruleStr.replace(/^RRULE:/i, '').trim();
  const parts = {};
  for (const pair of str.split(';')) {
    const eqIdx = pair.indexOf('=');
    if (eqIdx === -1) continue;
    const key = pair.substring(0, eqIdx).toUpperCase().trim();
    const val = pair.substring(eqIdx + 1).trim();
    if (key && val) parts[key] = val;
  }
  return parts;
}

function parseRRuleDate(str) {
  if (!str) return null;
  const m = str.match(/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})/);
  if (!m) return new Date(str);
  const iso = `${m[1]}-${m[2]}-${m[3]}T${m[4]}:${m[5]}:${m[6]}`;
  return str.endsWith('Z') ? new Date(iso + 'Z') : new Date(iso + '-03:00');
}

const DAY_MAP = { MO: 1, TU: 2, WE: 3, TH: 4, FR: 5, SA: 6, SU: 0 };

function addDays(d, n) { const r = new Date(d.getTime()); r.setDate(r.getDate() + n); return r; }
function addMonths(d, n) { const r = new Date(d.getTime()); r.setMonth(r.getMonth() + n); return r; }
function setTime(d, h, m, s) { d.setHours(h, m, s, 0); }

function getMonday(d) {
  const r = new Date(d.getTime());
  const day = r.getDay();
  const diff = day === 0 ? -6 : 1 - day;
  r.setDate(r.getDate() + diff);
  r.setHours(0, 0, 0, 0);
  return r;
}

function getWeekdayInWeek(weekStart, targetDay) {
  const d = new Date(weekStart.getTime());
  const diff = (targetDay - d.getDay() + 7) % 7;
  d.setDate(d.getDate() + diff);
  return d;
}

function toLocalDateStr(d) {
  return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
}

function generateOccurrences(rrule, dtstart, searchStart, searchEnd, exdatesSet, maxOcc) {
  const freq = (rrule.FREQ || '').toUpperCase();
  const interval = parseInt(rrule.INTERVAL || '1', 10);
  const count = rrule.COUNT ? parseInt(rrule.COUNT, 10) : null;
  const byDay = rrule.BYDAY ? rrule.BYDAY.split(',').map(s => s.trim()) : null;
  const byMonthDay = rrule.BYMONTHDAY ? rrule.BYMONTHDAY.split(',').map(Number) : null;
  const byHour = rrule.BYHOUR !== undefined ? parseInt(rrule.BYHOUR, 10) : dtstart.getHours();
  const byMinute = rrule.BYMINUTE !== undefined ? parseInt(rrule.BYMINUTE, 10) : dtstart.getMinutes();
  const bySecond = rrule.BYSECOND !== undefined ? parseInt(rrule.BYSECOND, 10) : 0;

  let untilDate = null;
  if (rrule.UNTIL) untilDate = parseRRuleDate(rrule.UNTIL);

  let effectiveEnd = new Date(searchEnd.getTime());
  if (untilDate && untilDate < effectiveEnd) effectiveEnd = untilDate;

  const results = [];
  let totalGen = 0;

  if (freq === 'DAILY') {
    let cur = new Date(dtstart.getTime());
    while (cur <= effectiveEnd && results.length < maxOcc) {
      if (count && totalGen >= count) break;
      if (cur >= dtstart) {
        totalGen++;
        const dk = toLocalDateStr(cur);
        if (cur >= searchStart && cur <= effectiveEnd && !exdatesSet.has(dk)) {
          const o = new Date(cur.getTime()); setTime(o, byHour, byMinute, bySecond);
          results.push(o);
        }
      }
      cur = addDays(cur, interval);
    }
  }
  else if (freq === 'WEEKLY') {
    const targetDays = byDay ? byDay.map(d => DAY_MAP[d.replace(/[^A-Z]/g,'')]) : [dtstart.getDay()];
    let wk = getMonday(dtstart);
    while (wk <= effectiveEnd && results.length < maxOcc) {
      if (count && totalGen >= count) break;
      for (const dayNum of targetDays) {
        if (count && totalGen >= count) break;
        const o = getWeekdayInWeek(wk, dayNum);
        setTime(o, byHour, byMinute, bySecond);
        if (o >= dtstart) {
          totalGen++;
          if (o >= searchStart && o <= effectiveEnd) {
            const dk = toLocalDateStr(o);
            if (!exdatesSet.has(dk)) results.push(new Date(o.getTime()));
          }
        }
      }
      wk = addDays(wk, 7 * interval);
    }
  }
  else if (freq === 'MONTHLY') {
    let cur = new Date(dtstart.getFullYear(), dtstart.getMonth(), 1);
    while (cur <= effectiveEnd && results.length < maxOcc) {
      if (count && totalGen >= count) break;
      const days = byMonthDay || [dtstart.getDate()];
      for (const day of days) {
        if (count && totalGen >= count) break;
        const last = new Date(cur.getFullYear(), cur.getMonth() + 1, 0).getDate();
        if (day > last) continue;
        const o = new Date(cur.getFullYear(), cur.getMonth(), day, byHour, byMinute, bySecond);
        if (o >= dtstart) {
          totalGen++;
          if (o >= searchStart && o <= effectiveEnd) {
            const dk = toLocalDateStr(o);
            if (!exdatesSet.has(dk)) results.push(new Date(o.getTime()));
          }
        }
      }
      cur = addMonths(cur, interval);
    }
  }
  else if (freq === 'YEARLY') {
    let cur = new Date(dtstart.getTime());
    while (cur <= effectiveEnd && results.length < maxOcc) {
      if (count && totalGen >= count) break;
      if (cur >= dtstart) {
        totalGen++;
        if (cur >= searchStart && cur <= effectiveEnd) {
          const dk = toLocalDateStr(cur);
          if (!exdatesSet.has(dk)) results.push(new Date(cur.getTime()));
        }
      }
      cur = new Date(cur.getFullYear() + interval, cur.getMonth(), cur.getDate(), byHour, byMinute, bySecond);
    }
  }
  return results;
}

// ─── EXPANDIR ───
const virtualOccurrences = [];

for (const evt of recorrentes) {
  const rrule = parseRRule(evt.rrule);
  const evtStart = new Date(evt.start_event);
  const evtEnd = evt.end_event ? new Date(evt.end_event) : null;
  const duration = evtEnd ? (evtEnd.getTime() - evtStart.getTime()) : 15 * 60 * 1000;

  const exdatesSet = new Set();
  if (evt.exdates && Array.isArray(evt.exdates)) {
    for (const ex of evt.exdates) {
      if (ex) exdatesSet.add(toLocalDateStr(new Date(ex)));
    }
  }

  let effEnd = new Date(rangeEnd.getTime());
  if (evt.repeats_until) {
    const ru = new Date(evt.repeats_until);
    if (ru < effEnd) effEnd = ru;
  }

  const occs = generateOccurrences(rrule, evtStart, rangeStart, effEnd, exdatesSet, 366);

  for (const occ of occs) {
    const occEnd = new Date(occ.getTime() + duration);
    virtualOccurrences.push({
      id: evt.id,
      event_name: evt.event_name,
      desc_event: evt.desc_event,
      start_event: occ.toISOString(),
      end_event: occEnd.toISOString(),
      reminder: evt.reminder,
      remembered: false,
      user_id: evt.user_id,
      is_recurring: true,
      rrule: evt.rrule,
      timezone: evt.timezone,
      connect_google: evt.connect_google,
      session_event_id_google: evt.session_event_id_google,
      calendar_email_created: evt.calendar_email_created,
      channel: evt.channel,
      active: evt.active,
      _is_virtual: true,
      _parent_id: evt.id
    });
  }
}

// ─── JUNTAR E ORDENAR ───
const all = [...normais, ...virtualOccurrences];
all.sort((a, b) => new Date(a.start_event) - new Date(b.start_event));

return all.map(e => ({ json: e }));
---FIM CODE EXPANDIR---

================================================================================
PASSO 4: REORGANIZAR CONEXOES
================================================================================

ANTES (fluxo atual):
  If1 (true) → Code4 → Get many rows9 → Aggregate8

DEPOIS:
  If1 (true) ──→ Code4 → Get many rows9 (normais) ──→ Merge (Append)
              └→ Get Recorrentes ─────────────────────→ Merge (Append)
                                                              ↓
                                                    Code: Expandir Recorrentes
                                                              ↓
                                                         Aggregate8
                                                              ↓
                                                         If5 → ...

ALTERNATIVA MAIS SIMPLES (sem Merge):
  Se voce nao quiser usar Merge, pode fazer a query de recorrentes
  DENTRO do Code node. Use um HTTP Request inline no Code:

  Mas isso nao e possivel no n8n Code node (nao tem acesso a HTTP).

  Entao a forma correta e:
  1. If1 (true) sai com DUAS conexoes:
     - Uma vai pro Code4 → Get many rows9
     - Outra vai pro Get Recorrentes
  2. Ambos convergem num Merge (Append)
  3. Merge sai pro Code Expandir
  4. Code Expandir sai pro Aggregate8

================================================================================
PASSO 5: TESTAR
================================================================================

1. Crie: "Dentista toda quinta 16:20"
   (RRULE: FREQ=WEEKLY;BYDAY=TH;BYHOUR=16;BYMINUTE=20;BYSECOND=0)

2. Busque agenda de 19/02 → deve aparecer Dentista 16:20
3. Busque agenda de 26/02 → AGORA deve aparecer Dentista 16:20
4. Busque agenda da semana → Dentista em toda quinta
5. Busque agenda do mes → Dentista em todas as quintas de fevereiro
